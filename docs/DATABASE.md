<h1>Database Schema &amp; Design</h1>

<p>
  This document outlines the database schema, table relationships, and indexing strategies 
  used in the <b>BalkanID File Vault</b> application.
</p>

<hr>

<h2>ðŸ“Š Entity-Relationship Diagram (ERD)</h2>
<p>
  The diagram below illustrates the relationship between the <code>users</code> and <code>files</code> tables.  
  A single user can own multiple files, representing a <b>one-to-many</b> relationship.
</p>

<p><i>
  This diagram can be generated by pasting the schema below into a tool like 
  <a href="https://dbdiagram.io" target="_blank">dbdiagram.io</a>.
</i></p>

<pre>
Table users {
  id integer [primary key]
  username varchar(100) [unique, not null]
  password_hash text [not null]
  storage_quota bigint [default: 10485760]
  role varchar(20) [default: 'user']
  email varchar(255) [unique]
}

Table files {
  id integer [primary key]
  user_id integer [not null, ref: > users.id]
  filename varchar(255) [not null]
  mime_type varchar(100) [not null]
  size bigint [not null]
  hash varchar(64) [not null]
  path text [not null]
  upload_date timestamp [default: CURRENT_TIMESTAMP]
  ref_count integer [default: 1]
  tags text[] [default: '{}']
  visibility varchar(20) [default: 'private']
  download_count integer [default: 0]
}
</pre>

<hr>

<h2>ðŸ“‹ Schema Breakdown</h2>

<h3>ðŸ”¹ <code>users</code> Table</h3>
<p>This table stores all user account information, including credentials, permissions, and storage limits.</p>

<table border="1" cellspacing="0" cellpadding="6">
  <thead>
    <tr>
      <th>Column</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>id</code></td><td>SERIAL PRIMARY KEY</td><td>Unique identifier for each user.</td></tr>
    <tr><td><code>username</code></td><td>VARCHAR(100) UNIQUE</td><td>The userâ€™s unique login name.</td></tr>
    <tr><td><code>password_hash</code></td><td>TEXT</td><td>The userâ€™s securely hashed password (using bcrypt).</td></tr>
    <tr><td><code>storage_quota</code></td><td>BIGINT</td><td>The maximum storage space (in bytes) allowed per user. Defaults to <b>10 MB</b>.</td></tr>
    <tr><td><code>role</code></td><td>VARCHAR(20)</td><td>Role for access control (e.g., <code>user</code>, <code>admin</code>). Defaults to <code>user</code>.</td></tr>
    <tr><td><code>email</code></td><td>VARCHAR(255) UNIQUE</td><td>The userâ€™s unique email address.</td></tr>
  </tbody>
</table>

<h3>ðŸ”¹ <code>files</code> Table</h3>
<p>
  This table stores metadata for every uploaded file and is central to the <b>deduplication logic</b>.
</p>

<p><b>Deduplication Logic:</b>  
Instead of storing every uploaded file, the system calculates a SHA-256 hash of the fileâ€™s content.  
If a file with the same <code>hash</code> and <code>user_id</code> already exists:
<ul>
  <li>The physical file is not stored again.</li>
  <li>The <code>ref_count</code> of the existing record is incremented.</li>
</ul>
A file is only deleted when its <code>ref_count</code> drops to zero.
</p>

<table border="1" cellspacing="0" cellpadding="6">
  <thead>
    <tr>
      <th>Column</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>id</code></td><td>SERIAL PRIMARY KEY</td><td>Unique identifier for each file record.</td></tr>
    <tr><td><code>user_id</code></td><td>INT</td><td>Foreign key referencing <code>users.id</code>.</td></tr>
    <tr><td><code>filename</code></td><td>VARCHAR(255)</td><td>The original name of the uploaded file.</td></tr>
    <tr><td><code>mime_type</code></td><td>VARCHAR(100)</td><td>The MIME type of the file (e.g., <code>image/png</code>).</td></tr>
    <tr><td><code>size</code></td><td>BIGINT</td><td>The file size in bytes.</td></tr>
    <tr><td><code>hash</code></td><td>VARCHAR(64)</td><td>SHA-256 hash of file content (used for deduplication).</td></tr>
    <tr><td><code>path</code></td><td>TEXT</td><td>Storage path of the physical file on the server.</td></tr>
    <tr><td><code>upload_date</code></td><td>TIMESTAMP</td><td>Date and time the file was uploaded.</td></tr>
    <tr><td><code>ref_count</code></td><td>INT</td><td>Reference counter for deduplication. Defaults to 1.</td></tr>
    <tr><td><code>tags</code></td><td>TEXT[]</td><td>Array of tags for filtering and searching. Defaults to empty array.</td></tr>
    <tr><td><code>visibility</code></td><td>VARCHAR(20)</td><td>File sharing status (<code>private</code> / <code>public</code>). Defaults to <code>private</code>.</td></tr>
    <tr><td><code>download_count</code></td><td>INT</td><td>Tracks how many times a public file has been downloaded. Defaults to 0.</td></tr>
  </tbody>
</table>

<hr>

<h2>âš¡ Indexing Strategy</h2>
<p>The following indexes are automatically created via <code>PRIMARY KEY</code> and <code>UNIQUE</code> constraints:</p>
<ul>
  <li>Index on <code>users(id)</code></li>
  <li>Index on <code>users(username)</code></li>
  <li>Index on <code>users(email)</code></li>
  <li>Index on <code>files(id)</code></li>
</ul>

<p><b>Recommended additional indexes for performance:</b></p>

<ul>
  <li>
    <b>Deduplication Checks:</b> Composite index on user ID and file hash.
    <pre>CREATE INDEX idx_files_user_hash ON files (user_id, hash);</pre>
  </li>
  <li>
    <b>Search Performance:</b> Index on filename for faster <code>ILIKE</code> searches.
    <pre>CREATE INDEX idx_files_filename ON files (filename);</pre>
  </li>
  <li>
    <b>Public File Listing:</b> Partial index to quickly find all public files.
    <pre>CREATE INDEX idx_files_public ON files (visibility) WHERE visibility = 'public';</pre>
  </li>
</ul>

<hr>